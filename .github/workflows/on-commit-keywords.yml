name: On Commit Keywords

on:
  push:

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  parse-commit:
    runs-on: ubuntu-latest
    env:
      PROJECT_V2_ID: ${{ vars.PROJECT_V2_ID }}
      PROJECT_FIELD_STATUS_NAME: ${{ vars.PROJECT_FIELD_STATUS_NAME }}
      STATUS_IN_PROGRESS: ${{ vars.STATUS_IN_PROGRESS }}
      STATUS_IN_REVIEW: ${{ vars.STATUS_IN_REVIEW }}
      COMMIT_KEYWORD_START: ${{ vars.COMMIT_KEYWORD_START }}
      COMMIT_KEYWORD_END: ${{ vars.COMMIT_KEYWORD_END }}
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const repo = context.repo;
            const commit = context.payload.head_commit;
            if (!commit) { core.info('No head_commit'); return; }

            const norm = (s) => String(s ?? '').trim();
            const msg = commit.message || '';

            const startKey = norm(process.env.COMMIT_KEYWORD_START || '[New]');
            const endKey   = norm(process.env.COMMIT_KEYWORD_END || '[END]');

            const newRe = new RegExp(`\${startKey}\s*\[#(\\d+)\]`, 'i');
            const endRe = new RegExp(`\${endKey}\s*\[#(\\d+)\]`, 'i');

            const newMatch = msg.match(newRe);
            const endMatch = msg.match(endRe);

            const issueNumber = Number((newMatch?.[1]) || (endMatch?.[1]) || 0);
            if (!issueNumber) { core.info('No issue reference found in latest commit message.'); return; }

            const targetStatusName = newMatch ? norm(process.env.STATUS_IN_PROGRESS) : norm(process.env.STATUS_IN_REVIEW);
            const statusFieldName = norm(process.env.PROJECT_FIELD_STATUS_NAME || 'Status');
            const projectId = norm(process.env.PROJECT_V2_ID);

            if (!projectId) { core.warning('PROJECT_V2_ID not set; skipping.'); return; }
            if (!targetStatusName) { core.warning('Target status name not set; skipping.'); return; }

            // Fetch issue node_id
            const issue = await github.rest.issues.get({ ...repo, issue_number: issueNumber });
            const issueNodeId = issue.data.node_id;

            // Project meta
            async function getProjectMeta(projectId) {
              const q = `
                query($id:ID!){
                  node(id:$id){
                    ... on ProjectV2 {
                      id
                      title
                      fields(first: 100) {
                        nodes {
                          __typename
                          ... on ProjectV2SingleSelectField {
                            id
                            name
                            options { id name }
                          }
                        }
                      }
                    }
                  }
                }`;
              const r = await github.graphql(q, { id: projectId });
              if (!r?.node?.id) throw new Error('Could not load ProjectV2 by ID.');
              return r.node;
            }

            async function findOrAddIssueItem(projectId, issueNodeId) {
              let after = null;
              while (true) {
                const q = `
                  query($id:ID!, $after:String){
                    node(id:$id){
                      ... on ProjectV2 {
                        items(first: 100, after: $after) {
                          pageInfo { hasNextPage endCursor }
                          nodes { id content { ... on Issue { id } } }
                        }
                      }
                    }
                  }`;
                const r = await github.graphql(q, { id: projectId, after });
                const nodes = r.node.items.nodes || [];
                const found = nodes.find(n => n.content?.id === issueNodeId);
                if (found) return found.id;

                const pi = r.node.items.pageInfo;
                if (!pi.hasNextPage) break;
                after = pi.endCursor;
              }

              const m = `
                mutation($projectId:ID!, $contentId:ID!){
                  addProjectV2ItemById(input:{ projectId:$projectId, contentId:$contentId }){ item { id } }
                }`;
              const add = await github.graphql(m, { projectId, contentId: issueNodeId });
              return add.addProjectV2ItemById.item.id;
            }

            async function setStatus(projectId, itemId, project, fieldName, optionName) {
              const field = project.fields.nodes.find(f => f.__typename === 'ProjectV2SingleSelectField' && f.name === fieldName);
              if (!field) throw new Error(`Field "${fieldName}" not found`);
              const opt = (field.options || []).find(o => o.name === optionName);
              if (!opt) throw new Error(`Option "${optionName}" not found for "${fieldName}"`);
              const m = `
                mutation($input: UpdateProjectV2ItemFieldValueInput!) {
                  updateProjectV2ItemFieldValue(input: $input) { projectV2Item { id } }
                }`;
              await github.graphql(m, { input: { projectId, itemId, fieldId: field.id, value: { singleSelectOptionId: opt.id } } });
            }

            try {
              const project = await getProjectMeta(projectId);
              const itemId = await findOrAddIssueItem(projectId, issueNodeId);
              await setStatus(projectId, itemId, project, statusFieldName, targetStatusName);
              core.info(`Updated issue #${issueNumber} status -> "${targetStatusName}"`);
            } catch (e) {
              core.warning(`Failed to update project status: ${e.message}`);
            }
