name: Remove PR & Issue from Project when Done

on:
  pull_request_review:
    types: [submitted]
  pull_request:
    types: [closed]

permissions:
  contents: read
  pull-requests: read
  issues: read

jobs:
  cleanup:
    runs-on: ubuntu-latest
    env:
      PROJECT_V2_ID: ${{ vars.PROJECT_V2_ID }}
      PROJECT_FIELD_STATUS_NAME: ${{ vars.PROJECT_FIELD_STATUS_NAME }}
      STATUS_DONE: ${{ vars.STATUS_DONE }}
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const repo = context.repo;
            const norm = (s) => String(s ?? '').trim();

            const isReview = context.eventName === 'pull_request_review' && context.payload.action === 'submitted';
            const isMerged = context.eventName === 'pull_request' && context.payload.action === 'closed' && context.payload.pull_request.merged === true;

            if (!isReview && !isMerged) return;

            if (isReview && (context.payload.review.state || '').toLowerCase() !== 'approved') {
              core.info('Review submitted but not APPROVED; skipping.');
              return;
            }

            const pr = context.payload.pull_request;
            if (!pr) return;

            const projectId = norm(process.env.PROJECT_V2_ID);
            const statusFieldName = norm(process.env.PROJECT_FIELD_STATUS_NAME || 'Status');
            const doneName = norm(process.env.STATUS_DONE || 'Done');

            if (!projectId) { core.info('PROJECT_V2_ID missing; skipping.'); return; }

            async function getProjectMeta(projectId) {
              const q = `
                query($id:ID!){
                  node(id:$id){
                    ... on ProjectV2 {
                      id
                      title
                      fields(first: 100) {
                        nodes {
                          __typename
                          ... on ProjectV2SingleSelectField {
                            id
                            name
                            options { id name }
                          }
                        }
                      }
                    }
                  }
                }`;
              const r = await github.graphql(q, { id: projectId });
              if (!r?.node?.id) throw new Error('Could not load ProjectV2 by ID.');
              return r.node;
            }

            async function listProjectItems(projectId) {
              const items = [];
              let after = null;
              while (true) {
                const q = `
                  query($id:ID!, $after:String){
                    node(id:$id){
                      ... on ProjectV2 {
                        items(first:100, after:$after){
                          pageInfo { hasNextPage endCursor }
                          nodes{
                            id
                            content { __typename ... on PullRequest { id } ... on Issue { id } }
                            fieldValues(first: 20){
                              nodes{
                                __typename
                                ... on ProjectV2ItemFieldSingleSelectValue {
                                  field { ... on ProjectV2SingleSelectField { name } }
                                  name
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }`;
                const r = await github.graphql(q, { id: projectId, after });
                items.push(...(r.node.items.nodes || []));
                const pi = r.node.items.pageInfo;
                if (!pi.hasNextPage) break;
                after = pi.endCursor;
              }
              return items;
            }

            function getStatusName(item) {
              const fv = item.fieldValues?.nodes || [];
              const v = fv.find(n => n.__typename === 'ProjectV2ItemFieldSingleSelectValue' && n.field?.name === statusFieldName);
              return v?.name || '';
            }

            async function deleteItem(itemId) {
              const m = `
                mutation($projectId:ID!, $itemId:ID!){
                  deleteProjectV2Item(input:{ projectId:$projectId, itemId:$itemId }){ deletedItemId }
                }`;
              await github.graphql(m, { projectId, itemId });
            }

            // Optional: determine linked issue from branch name "123_username"
            async function getLinkedIssueNodeIdFromBranch(ref) {
              const m = ref.match(/^(\d+)_/);
              if (!m) return null;
              const issue_number = Number(m[1]);
              if (!issue_number) return null;
              try {
                const issue = await github.rest.issues.get({ ...repo, issue_number });
                return issue.data.node_id;
              } catch (e) {
                core.info(`Could not fetch linked issue #${issue_number}: ${e.message}`);
                return null;
              }
            }

            try {
              const items = await listProjectItems(projectId);

              const prItem = items.find(it => it.content?.id === pr.node_id);
              const issueNodeId = await getLinkedIssueNodeIdFromBranch(pr.head.ref);
              const issueItem = issueNodeId ? items.find(it => it.content?.id === issueNodeId) : null;

              const candidates = [
                { kind: 'PR', item: prItem },
                { kind: 'Issue', item: issueItem },
              ].filter(x => x.item);

              if (!candidates.length) {
                core.info('No matching project items found; nothing to cleanup.');
                return;
              }

              for (const c of candidates) {
                const status = getStatusName(c.item);
                if (status !== doneName) {
                  core.info(`${c.kind} item status is "${status}" (not "${doneName}"); skipping deletion.`);
                  continue;
                }
                await deleteItem(c.item.id);
                core.info(`Deleted ${c.kind} item from project (status was Done).`);
              }
            } catch (e) {
              core.warning(`Cleanup failed: ${e.message}`);
            }
