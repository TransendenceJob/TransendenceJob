name: Move 'In review' tickets to Done on PR approval/merge

on:
  pull_request_review:
    types: [submitted]
  pull_request:
    types: [closed]

permissions:
  contents: read
  pull-requests: read
  issues: read

jobs:
  move-to-done:
    runs-on: ubuntu-latest
    env:
      PROJECT_V2_ID: ${{ vars.PROJECT_V2_ID }}
      PROJECT_FIELD_STATUS_NAME: ${{ vars.PROJECT_FIELD_STATUS_NAME }}
      STATUS_IN_REVIEW: ${{ vars.STATUS_IN_REVIEW }}
      STATUS_DONE: ${{ vars.STATUS_DONE }}
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT || secrets.GL_TOKEN || github.token }}
          script: |
            const repo = context.repo;
            const norm = (s) => String(s ?? '').trim();

            const isReview = context.eventName === 'pull_request_review' && context.payload.action === 'submitted';
            const isMerged = context.eventName === 'pull_request' && context.payload.action === 'closed' && context.payload.pull_request.merged === true;

            if (!isReview && !isMerged) return;

            if (isReview && (context.payload.review.state || '').toLowerCase() !== 'approved') {
              core.info('Review submitted but not APPROVED; skipping.');
              return;
            }

            const pr = context.payload.pull_request;
            if (!pr) return;

            const projectId = norm(process.env.PROJECT_V2_ID);
            const statusFieldName = norm(process.env.PROJECT_FIELD_STATUS_NAME || 'Status');
            const inReviewName = norm(process.env.STATUS_IN_REVIEW);
            const doneName = norm(process.env.STATUS_DONE);

            if (!projectId || !inReviewName || !doneName) {
              core.info('Missing project/status configuration; skipping.');
              return;
            }

            async function getProjectMeta(projectId) {
              const q = `
                query($id:ID!){
                  node(id:$id){
                    ... on ProjectV2 {
                      id
                      title
                      fields(first: 100) {
                        nodes {
                          __typename
                          ... on ProjectV2SingleSelectField {
                            id
                            name
                            options { id name }
                          }
                        }
                      }
                    }
                  }
                }`;
              const r = await github.graphql(q, { id: projectId });
              return r.node;
            }

            async function findItemByContentId(projectId, contentId) {
              let after = null;
              while (true) {
                const q = `
                  query($id:ID!, $after:String){
                    node(id:$id){
                      ... on ProjectV2 {
                        items(first: 100, after: $after) {
                          pageInfo { hasNextPage endCursor }
                          nodes {
                            id
                            content { __typename ... on PullRequest { id } ... on Issue { id } }
                            fieldValues(first: 20) {
                              nodes { __typename ... on ProjectV2ItemFieldSingleSelectValue { field { ... on ProjectV2SingleSelectField { name } } name } }
                            }
                          }
                        }
                      }
                    }
                  }`;
                const r = await github.graphql(q, { id: projectId, after });
                const items = r.node.items.nodes || [];
                for (const it of items) {
                  if (it.content?.id !== contentId) continue;
                  return it.id;
                }
                const pi = r.node.items.pageInfo;
                if (!pi.hasNextPage) break;
                after = pi.endCursor;
              }
              return null;
            }

            async function setStatus(projectId, itemId, project, optionName) {
              const field = project.fields.nodes.find(f => f.__typename === 'ProjectV2SingleSelectField' && f.name === statusFieldName);
              if (!field) throw new Error(`Field "${statusFieldName}" not found`);
              const opt = (field.options || []).find(o => o.name === optionName);
              if (!opt) throw new Error(`Option "${optionName}" not found`);
              const m = `
                mutation($input: UpdateProjectV2ItemFieldValueInput!) {
                  updateProjectV2ItemFieldValue(input: $input) { projectV2Item { id } }
                }`;
              await github.graphql(m, { input: { projectId, itemId, fieldId: field.id, value: { singleSelectOptionId: opt.id } } });
            }

            try {
              const project = await getProjectMeta(projectId);

              // This workflow tracks PR items in the project; if you only track Issues, you can adapt by mapping PR -> linked issue.
              const itemId = await findItemByContentId(projectId, pr.node_id);
              if (!itemId) {
                core.info('PR not found in project; skipping.');
                return;
              }

              // Move to Done (you can optionally check current status == In review, but not required)
              await setStatus(projectId, itemId, project, doneName);
              core.info(`Moved PR item to ${doneName}`);
            } catch (e) {
              core.warning(`Failed to move to Done: ${e.message}`);
            }
