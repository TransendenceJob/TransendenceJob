name: Issue Triage

on:
  issues:
    types: [opened, reopened, edited]

permissions:
  issues: write
  contents: read

jobs:
  triage:
    runs-on: ubuntu-latest
    env:
      # Project
      PROJECT_V2_ID: ${{ vars.PROJECT_V2_ID }}
      PROJECT_FIELD_STATUS_NAME: ${{ vars.PROJECT_FIELD_STATUS_NAME }}
      PROJECT_FIELD_PRIORITY_NAME: ${{ vars.PROJECT_FIELD_PRIORITY_NAME }}
      PROJECT_FIELD_SIZE_NAME: ${{ vars.PROJECT_FIELD_SIZE_NAME }}
      PROJECT_FIELD_IMPORTANCE_NAME: ${{ vars.PROJECT_FIELD_IMPORTANCE_NAME }}

      # Status option names
      STATUS_READY: ${{ vars.STATUS_READY }}
      STATUS_IN_PROGRESS: ${{ vars.STATUS_IN_PROGRESS }}
      STATUS_IN_REVIEW: ${{ vars.STATUS_IN_REVIEW }}
      STATUS_DONE: ${{ vars.STATUS_DONE }}
      STATUS_PULL_REQUESTS: ${{ vars.STATUS_PULL_REQUESTS }}
      # Optional (if you have Backlog): keep empty if not used
      STATUS_BACKLOG: ${{ vars.STATUS_BACKLOG }}

      # Labels (match your repo labels)
      LABEL_FEATURE: ${{ vars.LABEL_FEATURE }}
      LABEL_BUG: ${{ vars.LABEL_BUG }}
      LABEL_REFACTOR: ${{ vars.LABEL_REFACTOR }}
      LABEL_FIX: ${{ vars.LABEL_FIX }}

      # Importance options
      IMPORTANCE_URGENT: ${{ vars.IMPORTANCE_URGENT }}
      IMPORTANCE_MAIN: ${{ vars.IMPORTANCE_MAIN }}
      IMPORTANCE_SIDETRACK: ${{ vars.IMPORTANCE_SIDETRACK }}
      IMPORTANCE_OVERLOOKED: ${{ vars.IMPORTANCE_OVERLOOKED }}

      # Priority options
      PRIORITY_P0: ${{ vars.PRIORITY_P0 }}
      PRIORITY_P1: ${{ vars.PRIORITY_P1 }}
      PRIORITY_P2: ${{ vars.PRIORITY_P2 }}
      PRIORITY_P3: ${{ vars.PRIORITY_P3 }}

      # Size options
      SIZE_FAST: ${{ vars.SIZE_FAST }}
      SIZE_1_3_DAYS: ${{ vars.SIZE_1_3_DAYS }}
      SIZE_UP_TO_5_DAYS: ${{ vars.SIZE_UP_TO_5_DAYS }}
      SIZE_1_WEEK: ${{ vars.SIZE_1_WEEK }}
      SIZE_2_WEEKS_PLUS: ${{ vars.SIZE_2_WEEKS_PLUS }}

    steps:
      - name: Auto-triage issue (labels + project fields)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT  }}
          script: |
            const repo = context.repo;
            const issue = context.payload.issue;
            const issue_number = issue.number;
            const issue_node_id = issue.node_id;

            const title = (issue.title || '');
            const body = (issue.body || '');

            // ---------- Helpers ----------
            const norm = (s) => String(s ?? '').trim();
            const lower = (s) => norm(s).toLowerCase();

            function hasTag(text, tag) {
              return lower(text).includes(`[${lower(tag)}]`);
            }

            function pickFirstNonEmpty(...vals) {
              for (const v of vals) {
                const n = norm(v);
                if (n) return n;
              }
              return '';
            }

            function isFixIssue() {
              const fixLabel = lower(process.env.LABEL_FIX || 'fix');
              const currentLabels = (issue.labels || []).map(l => lower(l.name));
              return lower(title).includes('[fix]') || currentLabels.includes(fixLabel);
            }

            async function ensureLabels(labelNames) {
              const unique = [...new Set(labelNames.map(norm).filter(Boolean))];
              if (!unique.length) return;

              try {
                await github.rest.issues.addLabels({ ...repo, issue_number, labels: unique });
                core.info(`Added labels: ${unique.join(', ')}`);
              } catch (e) {
                core.warning(`Failed to add labels: ${e.message}`);
              }
            }

            // Project helpers: resolve field IDs + option IDs by NAME (no hardcoded IDs)
            async function getProjectMeta(projectId) {
              const q = `
                query($id:ID!){
                  node(id:$id){
                    ... on ProjectV2 {
                      id
                      title
                      fields(first: 100) {
                        nodes {
                          __typename
                          ... on ProjectV2SingleSelectField {
                            id
                            name
                            options { id name }
                          }
                        }
                      }
                    }
                  }
                }`;
              const r = await github.graphql(q, { id: projectId });
              if (!r?.node?.id) throw new Error('Could not load ProjectV2. Check PROJECT_V2_ID and token permissions.');
              return r.node;
            }

            async function findOrAddIssueItem(projectId, issueNodeId) {
              let after = null;
              while (true) {
                const q = `
                  query($id:ID!, $after:String){
                    node(id:$id){
                      ... on ProjectV2 {
                        items(first: 100, after: $after) {
                          pageInfo { hasNextPage endCursor }
                          nodes {
                            id
                            content { ... on Issue { id } }
                          }
                        }
                      }
                    }
                  }`;
                const r = await github.graphql(q, { id: projectId, after });
                const nodes = r.node.items.nodes || [];
                const found = nodes.find(n => n.content?.id === issueNodeId);
                if (found) return found.id;

                const pi = r.node.items.pageInfo;
                if (!pi.hasNextPage) break;
                after = pi.endCursor;
              }

              const m = `
                mutation($projectId:ID!, $contentId:ID!){
                  addProjectV2ItemById(input:{ projectId:$projectId, contentId:$contentId }) {
                    item { id }
                  }
                }`;
              const add = await github.graphql(m, { projectId, contentId: issueNodeId });
              return add.addProjectV2ItemById.item.id;
            }

            async function setSingleSelect(projectId, itemId, fieldName, optionName, project) {
              if (!norm(fieldName) || !norm(optionName)) return;

              const field = project.fields.nodes.find(f =>
                f.__typename === 'ProjectV2SingleSelectField' && f.name === fieldName
              );
              if (!field) {
                core.warning(`Field not found: ${fieldName}`);
                return;
              }
              const opt = (field.options || []).find(o => o.name === optionName);
              if (!opt) {
                core.warning(`Option not found for "${fieldName}": "${optionName}"`);
                core.info(`Available options: ${(field.options||[]).map(o=>o.name).join(' | ')}`);
                return;
              }

              const m = `
                mutation($input: UpdateProjectV2ItemFieldValueInput!) {
                  updateProjectV2ItemFieldValue(input: $input) { projectV2Item { id } }
                }`;
              await github.graphql(m, {
                input: {
                  projectId,
                  itemId,
                  fieldId: field.id,
                  value: { singleSelectOptionId: opt.id }
                }
              });
              core.info(`Set ${fieldName} = ${optionName}`);
            }

            // ---------- 1) Label assignment based on title tags ----------
            const labelsToAdd = [];

            if (lower(title).includes('[feature]')) labelsToAdd.push(process.env.LABEL_FEATURE || 'feature');
            if (lower(title).includes('[bug]')) labelsToAdd.push(process.env.LABEL_BUG || 'bug');
            if (lower(title).includes('[refactor]')) labelsToAdd.push(process.env.LABEL_REFACTOR || 'refactor');
            if (lower(title).includes('[fix]')) labelsToAdd.push(process.env.LABEL_FIX || 'fix');

            await ensureLabels(labelsToAdd);

            // ---------- 2) Parse fields from description ----------
            // Priority: allow either {P0..P3} OR [Importance:] Urgent/Main/Sidetrack/Overlooked
            const b = lower(body);

            const priorityField = norm(process.env.PROJECT_FIELD_PRIORITY_NAME);
            const sizeField = norm(process.env.PROJECT_FIELD_SIZE_NAME);
            const importanceField = norm(process.env.PROJECT_FIELD_IMPORTANCE_NAME);
            const statusField = norm(process.env.PROJECT_FIELD_STATUS_NAME);

            // Priority from {p0..p3}
            let priorityOpt = '';
            if (b.includes('{p0}')) priorityOpt = norm(process.env.PRIORITY_P0);
            else if (b.includes('{p1}')) priorityOpt = norm(process.env.PRIORITY_P1);
            else if (b.includes('{p2}')) priorityOpt = norm(process.env.PRIORITY_P2);
            else if (b.includes('{p3}')) priorityOpt = norm(process.env.PRIORITY_P3);

            // Importance from [Importance:]
            let importanceOpt = '';
            if (b.includes('[importance:] urgent')) importanceOpt = norm(process.env.IMPORTANCE_URGENT);
            else if (b.includes('[importance:] main')) importanceOpt = norm(process.env.IMPORTANCE_MAIN);
            else if (b.includes('[importance:] sidetrack')) importanceOpt = norm(process.env.IMPORTANCE_SIDETRACK);
            else if (b.includes('[importance:] overlooked')) importanceOpt = norm(process.env.IMPORTANCE_OVERLOOKED);

            // Size from [Duration:]
            let sizeOpt = '';
            if (b.includes('[duration:] 1 day')) sizeOpt = norm(process.env.SIZE_FAST);
            else if (b.includes('[duration:] 3 days')) sizeOpt = norm(process.env.SIZE_1_3_DAYS);
            else if (b.includes('[duration:] 5 days')) sizeOpt = norm(process.env.SIZE_UP_TO_5_DAYS);
            else if (b.includes('[duration:] 1 week')) sizeOpt = norm(process.env.SIZE_1_WEEK);
            else if (b.includes('[duration:] 2 weeks')) sizeOpt = norm(process.env.SIZE_2_WEEKS_PLUS);

            // ---------- 3) Ensure in Project and set fields ----------
            const projectId = norm(process.env.PROJECT_V2_ID);
            if (!projectId) {
              core.warning('PROJECT_V2_ID not set; skipping project updates.');
              return;
            }

            const project = await getProjectMeta(projectId);
            const itemId = await findOrAddIssueItem(projectId, issue_node_id);

            // Status: set to Backlog if configured; otherwise set to Ready (safe default)
            const statusBacklog = norm(process.env.STATUS_BACKLOG);
            const statusReady = norm(process.env.STATUS_READY);

            const targetStatus = pickFirstNonEmpty(statusBacklog, statusReady);
            if (targetStatus) {
              await setSingleSelect(projectId, itemId, statusField, targetStatus, project);
            }

            // Set priority/importance/size if configured and parsed
            if (priorityField && priorityOpt) await setSingleSelect(projectId, itemId, priorityField, priorityOpt, project);
            if (importanceField && importanceOpt) await setSingleSelect(projectId, itemId, importanceField, importanceOpt, project);
            if (sizeField && sizeOpt) await setSingleSelect(projectId, itemId, sizeField, sizeOpt, project);
