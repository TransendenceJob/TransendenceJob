name: Remove PR & Issue from Project

on:
  pull_request_review:
    types: [submitted]
  pull_request:
    types: [closed]

permissions:
  contents: read
  pull-requests: read
  issues: write

jobs:
  cleanup:
    runs-on: ubuntu-latest
    env:
      PROJECT_CLEANUP_ENABLED: ${{ vars.PROJECT_CLEANUP_ENABLED }}
      PROJECT_V2_ID: ${{ vars.PROJECT_V2_ID }}
      PROJECT_FIELD_STATUS_NAME: ${{ vars.PROJECT_FIELD_STATUS_NAME }}
      STATUS_DONE: ${{ vars.STATUS_DONE }}
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT || github.token }}
          script: |
            const enabled = String(process.env.PROJECT_CLEANUP_ENABLED || '').toLowerCase();
            if (enabled && enabled !== 'true') {
              core.info('Project cleanup disabled by vars.PROJECT_CLEANUP_ENABLED');
              return;
            }

            const repo = context.repo;
            const PROJECT_ID = process.env.PROJECT_V2_ID;
            if (!PROJECT_ID) throw new Error('Missing vars.PROJECT_V2_ID');

            const STATUS_FIELD_NAME = process.env.PROJECT_FIELD_STATUS_NAME || 'Status';
            const DONE_OPTION_NAME = process.env.STATUS_DONE || 'Done';

            // Event type
            const isReview = context.eventName === 'pull_request_review' && context.payload.action === 'submitted';
            const isMerged = context.eventName === 'pull_request' && context.payload.action === 'closed' && context.payload.pull_request.merged;
            if (!isReview && !isMerged) return;

            // For review events, only continue on APPROVED
            if (isReview && (context.payload.review.state || '').toLowerCase() !== 'approved') {
              core.info('Review is not APPROVED; skipping.');
              return;
            }

            const pr = context.payload.pull_request;
            if (!pr) return;

            // Resolve project fields/options
            const projQ = `
              query($projectId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    id
                    title
                    fields(first: 100) {
                      nodes {
                        __typename
                        ... on ProjectV2SingleSelectField { id name options { id name } }
                      }
                    }
                  }
                }
              }`;
            const projData = await github.graphql(projQ, { projectId: PROJECT_ID });
            const project = projData.node;
            if (!project) throw new Error('Project not found by ID');

            const statusField = project.fields.nodes.find(f => f && f.__typename === 'ProjectV2SingleSelectField' && f.name === STATUS_FIELD_NAME);
            if (!statusField) throw new Error(`Field "${STATUS_FIELD_NAME}" not found on project "${project.title}"`);

            const doneOpt = statusField.options.find(o => o.name === DONE_OPTION_NAME);
            if (!doneOpt) throw new Error(`Option "${DONE_OPTION_NAME}" not found`);

            // List all project items (paged)
            async function listProjectItems(projectId) {
              const items = [];
              let after = null;
              while (true) {
                const q = `
                  query($id:ID!, $after:String){
                    node(id:$id){
                      ... on ProjectV2 {
                        items(first:100, after:$after){
                          nodes{ id content { __typename ... on Issue { id number } ... on PullRequest { id number } } }
                          pageInfo { hasNextPage endCursor }
                        }
                      }
                    }
                  }`;
                const r = await github.graphql(q, { id: projectId, after });
                const page = r.node.items;
                items.push(...page.nodes);
                if (!page.pageInfo.hasNextPage) break;
                after = page.pageInfo.endCursor;
              }
              return items;
            }

            async function getStatus(projectId, itemId) {
              const q = `
                query($projectId:ID!, $itemId:ID!, $fieldName:String!){
                  node(id:$projectId){
                    ... on ProjectV2 {
                      item(id:$itemId){
                        id
                        fieldValueByName(name:$fieldName){
                          __typename
                          ... on ProjectV2ItemFieldSingleSelectValue { name optionId }
                        }
                      }
                    }
                  }
                }`;
              const r = await github.graphql(q, { projectId, itemId, fieldName: STATUS_FIELD_NAME });
              const fv = r.node.item?.fieldValueByName;
              if (!fv || fv.__typename !== 'ProjectV2ItemFieldSingleSelectValue') return null;
              return { name: fv.name, optionId: fv.optionId };
            }

            async function deleteItem(projectId, itemId) {
              await github.graphql(`
                mutation($projectId:ID!, $itemId:ID!){
                  deleteProjectV2Item(input:{ projectId:$projectId, itemId:$itemId }) { deletedItemId }
                }`, { projectId, itemId });
            }

            // Find linked issues for this PR
            const prQ = `
              query($owner:String!, $repo:String!, $number:Int!){
                repository(owner:$owner, name:$repo){
                  pullRequest(number:$number){
                    number
                    closingIssuesReferences(first:20){ nodes { number } }
                    body
                    title
                  }
                }
              }`;
            const prData = await github.graphql(prQ, { owner: repo.owner, repo: repo.repo, number: pr.number });
            const closingIssues = prData.repository.pullRequest.closingIssuesReferences.nodes || [];
            const text = (prData.repository.pullRequest.title || '') + '\n' + (prData.repository.pullRequest.body || '');
            const numsFromText = [...new Set((text.match(/#(\d+)/g) || []).map(s => +s.slice(1)))];
            const issueNumbers = [...new Set([...closingIssues.map(i => i.number), ...numsFromText])];

            const items = await listProjectItems(project.id);

            const prItem = items.find(n => n.content?.__typename === 'PullRequest' && n.content.number === pr.number);
            const issueItems = issueNumbers
              .map(num => ({ num, item: items.find(n => n.content?.__typename === 'Issue' && n.content.number === num) }))
              .filter(x => x.item)
              .map(x => ({ num: x.num, itemId: x.item.id }));

            // Policy:
            // - If merged: remove PR + linked issues from project.
            // - If approved (not merged): remove only if ALL linked issues are already Done.
            let canDelete = isMerged;
            if (!canDelete && issueItems.length) {
              let allDone = true;
              for (const it of issueItems) {
                const st = await getStatus(project.id, it.itemId);
                if (!st || st.optionId !== doneOpt.id) { allDone = false; break; }
              }
              canDelete = allDone;
            }

            if (!canDelete) {
              core.info('Conditions not met; skipping deletion.');
              return;
            }

            try {
              if (prItem) {
                await deleteItem(project.id, prItem.id);
                core.info(`Removed PR #${pr.number} from project.`);
              }
              for (const it of issueItems) {
                await deleteItem(project.id, it.itemId);
                core.info(`Removed Issue #${it.num} from project.`);
              }
            } catch (e) {
              core.warning(`Deletion failed: ${e.message}`);
            }
